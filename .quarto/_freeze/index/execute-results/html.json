{
  "hash": "41f001d846c9a7e3e12e97445cb6184a",
  "result": {
    "markdown": "---\ntitle: \"`shinytest2` = notes\"\nauthor: \"Martin Frigaard\"\nformat:\n  html:\n    toc: true\n    toc-depth: 5\n    toc-location: left\n    toc-expand: true\n    embed-resources: true\n    theme:\n      - flatly\n      - custom.scss\n        \ncode-fold: true\ncode-summary: view code\n\nexecute: \n  eval: false\n  echo: true\n  warning: false\n  message: false\n---\n\n\nThis quarto project covers the YouTube series on `shinytest2` ([Part 1](https://www.youtube.com/watch?v=Gucwz865aqQ), [Part 2](https://www.youtube.com/watch?v=7KLv6HdIxvU), and [Part 3](https://www.youtube.com/watch?v=xDxa_mDwN04)). The quoted text comes from the transcripts, which I've edited to capture the 'gist' of what is covered in each video. \n\n# Setup\n\nCheck out my [GitHub repository](https://github.com/mjfrigaard/greet) for getting setup with Chromium and [`chromote`](https://rstudio.github.io/chromote/) (and the app test files).\n\nThe inital application for the tutorial is below:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"view greet app\"}\nlibrary(shiny)\nlibrary(magrittr)\n\nui <- fluidPage(\n  textInput(\"name\", \"what is your name\"),\n  actionButton(\"greet\", \"Greet\"),\n  textOutput(\"greeting\"),\n  textOutput(\"first_letter\")\n)\n\nserver <- function(input, output, session) {\n    \n  output$greeting <- renderText({\n    req(input$name)\n    paste0(\"Hello \", input$name, \"!\")\n  }) %>% \n    bindEvent({input$greet})\n    \n  first_letter <- reactive({\n    req(input$name)\n    tolower(stringr::str_extract(input$name, \"^.\"))\n  }) %>% \n    bindEvent({input$greet})\n  \n  output$first_letter <- renderText({\n    paste0(\"The first letter in your name is \", first_letter(), \"!\")\n  })\n  \n}\n\nshinyApp(ui, server)\n```\n:::\n\n\n# Part I: [Example + basics](https://www.youtube.com/watch?v=Gucwz865aqQ)\n\n> *`shinytest2` is a wonderful package to help do regression testing for your Shiny applications. And we're going to perform this regression testing inside `testthat`. And it's not regression testing like linear model or something like that. This is a consistent behavior over time, and so we do not want it to regress, or we do not want it to change. That's what I mean for regression testing.*\n>\n> *Before we get into `shinytest2` and how it works, I just want to do this demo app. This demo app is short, a little toy example.*\n\n## App ui\n\n> *We have a `fluidPag()` that has a `textInput()`. It's like what's your name. We can fill it out. And then we also have an `actionButton()` of `\"greet\"`, the text `\"Greet\"`. And then we have two `textOutput()`s. One is a greeting, like `\"Hello, Barrett!\"` And then the other one is what is the first letter in your name. And it's neat, like it's short little app.*\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\" code-summary=\"view ui\"}\nui <- fluidPage(\n  textInput(\"name\", \"what is your name\"),\n  actionButton(\"greet\", \"Greet\"),\n  textOutput(\"greeting\"),\n  textOutput(\"first_letter\")\n)\n```\n:::\n\n\n> *So if I have it on here, I have `\"Barrett\"`*\n\n![](img/greet_01.png){width=\"3in\" fig-align=\"center\"}\n\n> *I click `Greet`. We get, `\"Hello Barrett!\"`*\n\n![](img/greet_02.png){width=\"3in\" fig-align=\"center\"}\n\n> *And if I'm here, we could do like `\"Shinytest2\"`*\n\n![](img/greet_03.png){width=\"3in\" fig-align=\"center\"}\n\n> *`\"What is your name?\"Shinytest2.\"`*\n\n![](img/greet_04.png){width=\"3in\" fig-align=\"center\"}\n\n> *`Greet`, `\"Hello Shinytest2.\"`* *The first letter is `S`.*\n>\n> *So it works. It's a nice little app.*\n\n## App server\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\" code-summary=\"view server\"}\nserver <- function(input, output, session) {\n    \n  output$greeting <- renderText({\n    req(input$name)\n    paste0(\"Hello \", input$name, \"!\")\n  }) %>% \n    bindEvent({input$greet})\n    \n  first_letter <- reactive({\n    req(input$name)\n    tolower(stringr::str_extract(input$name, \"^.\"))\n  }) %>% \n    bindEvent({input$greet})\n  \n  output$first_letter <- renderText({\n    paste0(\"The first letter in your name is \", first_letter(), \"!\")\n  })\n  \n}\n```\n:::\n\n\n> *The app for the `server`-- what it does is we have a `renderText()` that requires the name and given a `Greet` click, we will say, `\"Hello\"` name. And then for the first letter calculation, we require a name, and we extract the first character of the name. And we send it `tolower()`. And we will bind all of that calculations to when the `Greet` button is clicked. Given this first letter, whenever it updates, we will then call `renderText()` and say the first letter in your name is this first letter. Awesome.*\n>\n> *So let's imagine that I have---well I have now created this app, or I am working on a team, and I want to make sure that behaviors are consistent. And tests are worth so much, because you don't necessarily need to communicate that because the test is there. And if the test breaks, then we can figure out what's happening.*\n>\n> *And this also allows you to do other things like sweeping code changes. Like what if I want to change the guts of how first letter is calculated. I know this is a small function, but it could be much more complicated. And having tests allow you to do these sweeping changes with confidence, otherwise you just look out and go, no, that's close enough. I don't know. I hope I covered everything. At least with tests, we can say all of the tests pass. And if you're missing something, we can add them in and then make your test more robust.*\n\n## Recording tests\n\n> *When you run `record_test()`, it opens up Running `record_test()` your application in the Chrome browser or Chromium based browser. Mine by default is set to Chrome.*\n\n![](img/chromium.png){width=\"6in\" fig-align=\"center\"}\n\n> *It'll have your app in this IFrame. And on the sidebar is actually the recorder. And we can see there's some buttons to call **Expect Shiny** values or **Expect screenshot**. And then there's also an area of all the code that will be executed later that is able to replay your recording. So let's make a recording:*\n\n![](img/shinytest2.png){width=\"6in\" fig-align=\"center\"}\n\n### Input, output, expect shiny values\n\n> *This is*\n>\n> \"*What is your name?*\"\\*\n>\n> *My name is `\"Barrett\"`*\n>\n> *So let's `Greet` Barrett. And it'll say,*\n>\n> *\"Hello Barret! The first letter in your name is b!\"*\n>\n> *And we can see that I set inputs, name is **`\"Barrett\"`**. And then I clicked the `Greet` button, and then an output value is updated. Awesome.*\n\n![](img/record_test_01.png){width=\"6in\" fig-align=\"center\"}\n\n> *...I can save this as \"`hello-barrett`\" because that is the name that I used and just for my reference...I need to say, **Expect Shiny values**. And this will keep track-- **the expect values will keep track of all your input, output, and exported values.** And exported values, we'll get to in another video. So once we have at least one expectation, we can then click **Save test and exit**.*\n\n![](img/expect_shiny_values.png){width=\"6in\" fig-align=\"center\"}\n\n> *This will save the test and then immediately run the test-- play back the test again. And there are some warnings, because we have some new snapshots. But that's OK. And it looks like it all passed, because there's also nothing to say that the snapshots would fail. So let's take a look at what was created.*\n\n\n::: {.cell}\n\n```{.txt .cell-code  code-fold=\"true\" code-summary=\"view record_test() output\"}\n• Saving test runner: tests/testthat.R\n• Saving test file: tests/testthat/test-shinytest2.R\n✔ Adding 'shinytest2::load_app_env()' to 'tests/testthat/setup-shinytest2.R'\n• Modify '/Users/mjfrigaard/projects/dev/greet/tests/testthat/test-shinytest2.R'\n• Running recorded test: tests/testthat/test-shinytest2.R\n✔ | F W S  OK | Context\n✔ |   2     1 | shinytest2 [2.5s]                                                                  \n────────────────────────────────────────────────────────────────────────────────\nWarning (test-shinytest2.R:7:3): {shinytest2} recording: hello-barret\nAdding new file snapshot: 'tests/testthat/_snaps/hello-barret-001_.png'\n\nWarning (test-shinytest2.R:7:3): {shinytest2} recording: hello-barret\nAdding new file snapshot: 'tests/testthat/_snaps/hello-barret-001.json'\n────────────────────────────────────────────────────────────────────────────────\n\n══ Results ═════════════════════════════════════════════════════════════════════\nDuration: 2.9 s\n\n[ FAIL 0 | WARN 2 | SKIP 0 | PASS 1 ]\n```\n:::\n\n\n## tests/ folder\n\n> *...and then the `tests` folder, it will be a sibling to that. We'll go inside that in a second.*\n\n\n::: {.cell}\n\n```{.txt .cell-code  code-fold=\"show\" code-summary=\"view tests folder\"}\ntests\n├── testthat\n│   ├── _snaps\n│   │   └── shinytest2\n│   │       ├── hello-barret-001.json\n│   │       └── hello-barret-001_.png\n│   ├── setup-shinytest2.R\n│   └── test-shinytest2.R\n└── testthat.R\n\n4 directories, 5 files\n```\n:::\n\n\n### tests/testthat.R\n\n> *And in there, we will have a `testthat.R` which internally, it just has `shinytest2::test_app()`*\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\" code-summary=\"view testthat.R contents\"}\nshinytest2::test_app()\n```\n:::\n\n\n> *And then next to the `testthat.R` is a `testthat` folder. There there's three parts here. The first part is the `_snaps` folder.*\n\n### setup-shinytest2.R\n\n> *The second one is the `setup.R`. `setup.R` is there for ... more complicated apps ... where you have an R folder or you have `global.R` in your Shiny application. We load all of this information inside `setup.R`, so that your tests have that information available.*\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\" code-summary=\"view setup-shinytest2.R contents\"}\n# Load application support files into testing environment\nshinytest2::load_app_env()\n```\n:::\n\n\n### test-shinytest2.R\n\n> *And the last one is `test-shinytest2`.*\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\" code-summary=\"view test-shinytest2 contents\"}\nlibrary(shinytest2)\n\ntest_that(\"{shinytest2} recording: hello-barret\", {\n  app <- AppDriver$new(name = \"hello-barret\", height = 483, width = 862)\n  app$set_inputs(name = \"Barret\")\n  app$click(\"greet\")\n  app$expect_values()\n})\n```\n:::\n\n\n#### Test structure \n\n-   Below are the components of the test: \n\n    -   > *This is the default file name for recordings. And it'll say `shinytest2` recording-- *`\"whatever name you gave\"`*.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"false\"}\n    test_that(\"{shinytest2} recording: hello-barret\", {\n    ```\n    :::\n\n    \n    -   > It gives the same height and width of the recording window. That way when it replays, it's under the same height and width:\n    \n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"false\"}\n    app <- AppDriver$new(name = \"hello-barret\", height = 483, width = 862)\n    ```\n    :::\n\n    \n    -   > We then say `app$set_inputs`...I typed in `\"Barrett\"` for the name  \n    \n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"false\"}\n    app$set_inputs(name = \"Barret\")\n    ```\n    :::\n\n    \n    -   > I then clicked the `Greet` button\n    \n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"false\"}\n    app$click(\"greet\")\n    ```\n    :::\n\n    \n    -   > ...and then we called `app$expect_values`.*\n    \n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"false\"}\n    app$expect_values()\n    })\n    ```\n    :::\n\n    \n> *Expect values is actually a wrapper around `teststhat`, `expect_snapshot_file()`. This file will contain a `JSON` representation of your input, output, and export values. And that is stored in the `_snaps` folder.*\n> \n> *So we will open up `_snaps`. We'll open up `shinytest2`, because that is the name of the file, `shinytest2`. So that name. And then there was the first JSON file that was created.*\n\n## _snaps/ folder\n\n\n::: {.cell}\n\n```{.txt .cell-code  code-fold=\"show\" code-summary=\"view _snaps folder\"}\ntests/testthat/_snaps\n└── shinytest2\n    ├── hello-barret-001.json\n    └── hello-barret-001_.png\n2 directories, 2 files\n```\n:::\n\n\n> *And this one if we click it, has my `input`, `output`, and `export`.*\n\n``` json\n{\n  \"input\": {\n    \"greet\": 1,\n    \"name\": \"Barret\"\n  },\n  \"output\": {\n    \"first_letter\": \"The first letter in your is b!\",\n    \"greeting\": \"Hello Barret!\"\n  },\n  \"export\": {\n\n  }\n}\n```\n\n> *So my inputs is at the time of calling `expect_values()`, which was after setting an `input` and after clicking `Greet` button. We have `input` of `\"greet\": 1` for one time to click the button. And name was `\"Barrett\"`*\n\n::: {.panel-tabset}\n\n## App\n\n![](img/record_test_03.png){width=\"3in\"}\n\n## JSON\n\n``` JSON\n  \"input\": {\n    \"greet\": 1,\n    \"name\": \"Barret\"\n  }\n```\n\n:::\n\n> *The `output` was `\"first_letter\"` was, `\"The first letter your name is b!\"` And the greeting is, `\"Hello Barrett!\"` We didn't export any test values yet. But we'll get into that in a later video.*\n\n::: {.panel-tabset}\n\n## App\n\n![](img/record_test_04.png){width=\"3in\"}\n\n## JSON\n\n``` JSON\n  \"output\": {\n    \"first_letter\": \"The first letter in your is b!\",\n    \"greeting\": \"Hello Barret!\"\n  }\n```\n\n:::\n\n> *So this is our test. This is awesome. We can, if we want, change the height and width. We can add more tests. This is our test file to work with.*\n\n### Image files\n\nA note on `.png` files created during testing:\n\n> *As a side note, you might notice that there's a PNG file here created next to the JSON file. This is there, because images typically are fairly brittle. And we don't like to use them if we can help it, because there's lots of things outside of our control that we can't account for, such as if the R version updates, or let's say you change your version of DT, or let's say you update your system font. There's many different things that are outside of Shiny or R that are not in your control. And screenshots will fail if this happens. And no one likes to see that, but that'll happen. So if you can, try to do everything as much as possible using your JSON or your values, and try to just test the things that you own. Unless you're a package developer, then by all means, we need to start taking pictures and making sure things render properly. But otherwise, we can give that responsibility back to the package developers, not us as app developers. But the image is there to take us a snapshot to let us know what the app look like when we called expect values.*\n\n\n\n> *So let's do, `hello-barrett-001`.*\n\n![](img/hello-barret-001_.png){width=\"8in\" fig-align=\"center\"}\n\n> *And this will open up my application. And we can see that Chromote believes the app looked like this where it says,*\n\n> `\"What is your name?\"`\n> `\"Barret.\"` \n> \n> `Greet` \n> \n> `\"Hello Barret!\" \"Your first letter name is b\"`\n\n> *Awesome. That worked out great.*\n\n## Debugging \n\n> *So one of the things that we can do interactively is we can take our app, and we can run it in the console*\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\" code-summary=\"run in console\"}\napp <- AppDriver$new(name = \"hello-barret\", height = 483, width = 862)\n```\n:::\n\n\n> *As long as we're sitting in our working directory of our Shiny application. This uses the `AppDriver` object. And this object is something that drives `shinytest2` And it runs your Shiny application in the background. And it also does your communication with Chromote. And so it handles all of that. And we can set our `inputs`. We can also retrieve `inputs`, and `outputs`, or different values, and click many different things*\n\n### `app$view()`\n\n> *So if we do this, one of the things that I really enjoy is that we can call `app$view`, and view will open up a web page Using `app$view()` to open a visual representation of our headless Chrome browser. And I think this is really neat because now it's not a black box as to what is happening.*\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\" code-summary=\"run in console\"}\napp$view()\n```\n:::\n\n\n![](img/app_view.png){width=\"8in\" fig-align=\"center\"}\n\n### `app$set_inputs()`\n\n> *So now I have my app. And this is what Chromote is representing as-- what is happening within the app. So if we actually just step through this code when in time, we can actually see the app update to the left. So we can call `set_inputs(name=\"Barret\")`.* \n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\" code-summary=\"run in console\"}\napp$set_inputs(name = \"Barret\")\n```\n:::\n\n\n![](img/app_set_inputs.png){width=\"8in\" fig-align=\"center\"}\n\n> *Click `Greet`.* \n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\" code-summary=\"run in console\"}\napp$click(\"greet\")\n```\n:::\n\n\n![](img/app_click.png){width=\"8in\" fig-align=\"center\"}\n\n### `app$get_values()`\n\n> *And then if I wanted to, I could call `app$expect_values()`, or I could even say `app$get_values`. And this will return all the values.* \n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\" code-summary=\"run in console\"}\napp$get_values()\n```\n:::\n\n```\n$input\n$input$greet\n[1] 2\nattr(,\"class\")\n[1] \"shinyActionButtonValue\" \"integer\"               \n\n$input$name\n[1] \"Barret\"\n\n\n$output\n$output$first_letter\n[1] \"The first letter in your name is b!\"\n\n$output$greeting\n[1] \"Hello Barret!\"\n\n\n$export\nnamed list()\n```\n\n\n### `app$get_value()`\n\n> *Or if I wanted to do something like just a particular one, I could say `app$get_values(output = \"greeting\")`. And it's just that one particular value. Or since if it's just your one value, you can say get value and it'll turn back the regular result.*\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\" code-summary=\"run in console\"}\napp$get_values(output = \"greeting\")\n```\n:::\n\n```\n[1] \"Hello Barret!\"\n```\n\n### Run tests\n\n> *So it's very exciting. You can debug your headless tiny application, and headless Chrome instance, and your Shiny application all at the same time. Save the code that you want. And then we can replay them afterwards. Or just going in the top right and saying, **Run tests**. You will load up. We'll get there and eventually pass one for that `expect_values`, because that's the only expectation in this whole test file.*\n\n```\n==> Testing R file using 'testthat'\n\nLoading required package: shiny\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 1 ]\nTest complete\n```\n\n> *Test complete. Perfect.*\n\n# Part 2: [Exporting values](https://www.youtube.com/watch?v=7KLv6HdIxvU)\n\n## Introduction\n\n> *So sometimes just knowing your inputs and your outputs is not enough because you knowthey can hide kind of the middle interactions of your reactives. I know this is a smaller app but it tries to get across the point of we can export these inner reactive values it's not just your inputs and outputs you can export these inner reactives*\n\n## Exporting reactives\n\n> *So I'm interested in this `first_letter`...*\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\" code-summary=\"first_letter reactive\"}\n  first_letter <- reactive({\n    req(input$name)\n    tolower(stringr::str_extract(input$name, \"^.\"))\n  }) %>% \n    bindEvent({input$greet})\n```\n:::\n\n\n\n> *I know the phrasing of the `first_letter` in your name is `b` or whatever the first part of your name is but I want to actually just have that letter as a value that I can test against so we have our recording and I'm going to adjust this copy and adjust this recording and I'm going to do some alterations for it so we can export those test values.*\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\" code-summary=\"previous hello-barret recording\"}\ntest_that(\"{shinytest2} recording: hello-barret\", {\n  app <- AppDriver$new(name = \"hello-barret\", height = 483, width = 862)\n  app$set_inputs(name = \"Barret\")\n  app$click(\"greet\")\n  app$expect_values()\n})\n```\n:::\n\n\n> *Let's call a new test...\"export test values\"*\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\" code-summary=\"testthat desc\"}\ntest_that(\"export test values\", {\n  \n})\n```\n:::\n\n\n\n\n> *We'll say `\"export values\"`...the app is not going to be doing anything specific with screenshots...the app is not dependent on the width so I'm going to remove the height and width restriction and just use the defaults...*\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\" code-summary=\"AppDriver name\"}\ntest_that(desc = \"export test values\", code = {\n  # use default height/width\n  app <- AppDriver$new(name = \"export values\") \n})\n```\n:::\n\n\n> *I'm going to set the `inputs` of `name = Barrett\"` and I'm going to click `greet`*\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\" code-summary=\"set_inputs & actionButton\"}\ntest_that(desc = \"export test values\", code = {\n  # use default height/width\n  app <- AppDriver$new(name = \"export values\") \n  app$set_inputs(name = \"Barret\")\n  app$click(\"greet\")\n})\n```\n:::\n\n\n> *One thing we could do here is `app$get_value()`...and we want to say `output = first_letter`...*\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\" code-summary=\"get_value(output = )\"}\ntest_that(desc = \"export test values\", code = {\n  # use default height/width\n  app <- AppDriver$new(name = \"export values\") \n  app$set_inputs(name = \"Barret\")\n  app$click(\"greet\")\n  # extract value from output value:\n  first_letter_phrase <- app$get_value(output = \"first_letter\")\n  \n})\n```\n:::\n\n\n\n> *if I'm running the application this should be this phrase so I'm gonna say not just the `first_letter` but the first letter phrase...and we'll say `expect_equal()` to `first_letter_phrase` and `\"The first letter in my name is b!\"`*\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\" code-summary=\"expect_equal()\"}\ntest_that(desc = \"export test values\", code = {\n  # use default height/width\n  app <- AppDriver$new(name = \"export values\") \n  app$set_inputs(name = \"Barret\")\n  app$click(\"greet\")\n  # extract value from \n  first_letter_phrase <- app$get_value(output = \"first_letter\")\n  expect_equal(object = first_letter_phrase, \n    expected = \"The first letter in your name is b!\")\n  \n})\n```\n:::\n\n\n> *For now I'm just going to comment that earlier test we're going to just run all the tests right here*\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"complete test\"}\nlibrary(testthat)\nlibrary(shinytest2)\n\n# test_that(\"{shinytest2} recording: hello-barret\", {\n#   app <- AppDriver$new(name = \"hello-barret\", height = 483, width = 862)\n#   app$set_inputs(name = \"Barret\")\n#   app$click(\"greet\")\n#   app$expect_values()\n# })\n\ntest_that(desc = \"export test values\", code = {\n  # use default height/width\n  app <- AppDriver$new(name = \"export values\") \n  app$set_inputs(name = \"Barret\")\n  app$click(\"greet\")\n  \n  # extract value from output$first_letter\n  first_letter_phrase <- app$get_value(output = \"first_letter\")\n  expect_equal(object = first_letter_phrase, \n    expected = \"The first letter in your name is b!\")\n  \n})\n```\n:::\n\n\n### Run in console\n\n> *...just because it's fun to see this interactively...I'm taking a guess that first letter phrase is this first letter phrase...it does equal `\"The first letter your name is b!\"`*\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\" code-summary=\"in console\"}\napp <- AppDriver$new(name = \"export values\")\napp$set_inputs(name = \"Barret\")\napp$click(\"greet\")\nfirst_letter_phrase <- app$get_value(output = \"first_letter\")\nfirst_letter_phrase\n#>> [1] \"The first letter in your name is b!\"\n```\n:::\n\n\n\n### Run test\n\n```\n==> Testing R file using 'testthat'\n\nLoading required package: shiny\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 1 ]\nDeleting unused snapshots:\n• shinytest2/hello-barret-001_.png\n• shinytest2/hello-barret-001.json\n\nTest complete\n```\n\n\n> *so this `expect_equal()` passed and we a little warning of deleting unused screenshots or snapshots...because I commented this test...so that is like those tests don't exist anymore...so we shall delete them and that's okay...if I undo this and rerun it...those snapshots will come right back*\n\n\n## exportTestValues()\n\n> *So this is how we can get the whole phrase...but the thing i was interested in was the letter `b`...this is where...[we use]...`exportTestValues()`...and that we can export those values...so there's a method under shiny called export test values*\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\" code-summary=\"exportTestValues\"}\nshiny::exportTestValues()\n```\n:::\n\n\n> *`exportTestValues()` is a key to reactive expression set of arguments*\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\" code-summary=\"exportTestValues first_letter\"}\nshiny::exportTestValues(\n  first_letter = \n    first_letter()\n  )\n```\n:::\n\n\n> *I could say `first_letter` (it doesn't really matter it's my own custom key but just gonna for consistency I'm gonna just call it `first_letter`)...this will equal the reactive equal to the output of the reactive expression* \n\nIn `app.R`:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\" code-summary=\"exportTestValues from app\"}\nserver <- function(input, output, session) {\n    \n  output$greeting <- renderText({\n    req(input$name)\n    paste0(\"Hello \", input$name, \"!\")\n  }) %>% \n    bindEvent({input$greet})\n    \n  first_letter <- reactive({\n    req(input$name)\n    tolower(stringr::str_extract(input$name, \"^.\"))\n  }) %>% \n    bindEvent({input$greet})\n  \n  output$first_letter <- renderText({\n    paste0(\"The first letter in your name is \", first_letter(), \"!\")\n  })\n  \nshiny::exportTestValues(\n  first_letter = \n    first_letter()\n  )\n  \n}\n```\n:::\n\n\n\n### Reset AppDriver\n\n> *I will kill the old [app] with `app$stop`, and then let's actually get us back into the state that we are at...so let's make a new `AppDriver`*\n\nIn console:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\" code-summary=\"reset AppDriver\"}\napp$stop()\napp <- AppDriver$new(name = \"export values\")\n```\n:::\n\n\n### Get exported values \n\n> *Let's call `app$set_inputs()` let's `app$click()`...let's look at the values that are currently in the app with `app$get_values()`*\n\nIn console:\n\n> *so [`app$get_values()`] will return all the `input`, `output`, and `exported` values*\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\" code-summary=\"set_input/actionButton\"}\napp$set_inputs(name = \"Barret\")\napp$click(\"greet\")\napp$get_values()\n#>> $input\n#>> $input$greet\n#>> [1] 1\n#>> attr(,\"class\")\n#>> [1] \"shinyActionButtonValue\" \"integer\"               \n#>>\n#>> $input$name\n#>> [1] \"Barret\"\n#>>\n#>>\n#>> $output\n#>> $output$first_letter\n#>> [1] \"The first letter in your name is b!\"\n#>>\n#>> $output$greeting\n#>> [1] \"Hello Barret!\"\n#>>\n#>>\n#>> $export\n#>> $export$first_letter\n#>> [1] \"b\"\n```\n:::\n\n\n> *so we have our `inputs`: we have `input$greet` and `input$name`...we have our `outputs` of `output$first_letter` and `output$greeting`...and then we have `export$first_letter`, and now we have access to this reactive value [`\"b\"`]*\n\n### Test exported values \n\n> *It doesn't need to be an `output`, we can just use an `exported` value. So for this one we can also say `app$get_value()` of `export = first_letter`* \n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\" code-summary=\"get_value/export\"}\napp$get_value(export = \"first_letter\")\n```\n:::\n\n\n\n> *I'm more interested in `export$first_letter`, so i will say `export = first_letter` and we'll do `expect_equal()` to `\"b\"`*\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\" code-summary=\"expect_equal() get_value/export b\"}\ntest_that(desc = \"export test values\", code = {\n  # use default height/width\n  app <- AppDriver$new(name = \"export values\") \n  app$set_inputs(name = \"Barret\")\n  app$click(\"greet\")\n  \n  # extract value from output$first_letter\n  first_letter_phrase <- app$get_value(output = \"first_letter\")\n  \n  expect_equal(object = first_letter_phrase, \n    expected = \"The first letter in your name is b!\")\n  \n  expect_equal(\n    object = app$get_value(export = \"first_letter\"),\n    expected = \"b\"\n  )\n  \n})\n```\n:::\n\n\n> *and if I run this it passes*\n\n\n::: {.cell}\n\n```{.bash .cell-code  code-fold=\"false\"}\n==> Testing R file using 'testthat'\n\nLoading required package: shiny\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 2 ]\nTest complete\n```\n:::\n\n\n\n> *just for proof if I change it to a `\"j\"`*\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\" code-summary=\"expect_equal() get_value/export j\"}\ntest_that(desc = \"export test values\", code = {\n  # use default height/width\n  app <- AppDriver$new(name = \"export values\") \n  app$set_inputs(name = \"Barret\")\n  app$click(\"greet\")\n  \n  # extract value from output$first_letter\n  first_letter_phrase <- app$get_value(output = \"first_letter\")\n  \n  expect_equal(object = first_letter_phrase, \n    expected = \"The first letter in your name is b!\")\n  \n  expect_equal(\n    object = app$get_value(export = \"first_letter\"),\n    expected = \"b\"\n  )\n  \n})\n```\n:::\n\n\n\n> *and I run it it'll say*\n\n\n::: {.cell}\n\n```{.bash .cell-code  code-fold=\"false\"}\n==> Testing R file using 'testthat'\n\nLoading required package: shiny\n[ FAIL 1 | WARN 0 | SKIP 0 | PASS 1 ]\n\n── Failure (test-shinytest2.R:23:3): export test values ────────────────────────\napp$get_value(export = \"first_letter\") not equal to \"j\".\n1/1 mismatches\nx[1]: \"b\"\ny[1]: \"j\"\n\n[ FAIL 1 | WARN 0 | SKIP 0 | PASS 1 ]\n\nTest complete\n```\n:::\n\n\n> *error found `actual is \"b\" but you expected \"j\"`*\n\n> *so you do want `\"b\"`, so I'll change it back and run it just to confirm...then I will run all the tests because...we should be able to run these all the time quickly...*\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\" code-summary=\"final exported values unit test\"}\ntest_that(desc = \"export test values\", code = {\n  # use default height/width\n  app <- AppDriver$new(name = \"export values\") \n  app$set_inputs(name = \"Barret\")\n  app$click(\"greet\")\n  \n  # extract value from output$first_letter\n  first_letter_phrase <- app$get_value(output = \"first_letter\")\n  \n  expect_equal(object = first_letter_phrase, \n    expected = \"The first letter in your name is b!\")\n  \n  expect_equal(\n    object = app$get_value(export = \"first_letter\"),\n    expected = \"b\"\n  )\n  \n})\n```\n:::\n\n\n\n> *great now we have two checks passed.* \n\n# Part 3: [Using shiny.testmode](https://youtu.be/xDxa_mDwN04)\n\n## Introduction \n\n> *So this example has some serious effects for production sized apps, where you have authentication or things that testing should not be confirming.*\n\n## Testing production apps\n\n> *One of the difficulties when doing production size apps and ... unit tests is interacting with outside sources. This can be authentication ... This can be database requests... And one of the things that we recommend you do is you listen to a flag or a global option of `shiny.testmode`.*\n>\n> *And if `shiny.testmode` is `TRUE`, I recommend having a different UI, or server, or reactive behavior given this flag. And you can have things like the authentication isn't even addressed.*\n> \n> *If I do a restricted database call, maybe instead I load a CSV of information. We're not testing the database--we're actually just testing the Shiny app. So we need to try to isolate our test to what we can control. And using this flag, we can turn that behavior on or turn it off. And it's really great...as how you can override your apps' default behavior.*\n>\n\n### Authenticated database request\n\n> *So let's look at the app that we've been doing in the past two videos where we ask our name, and it'll tell us the first part, or first letter of our name. And then let's just add in a third field of `penguins`. And so to lighten the mood a little bit, we're going to say \"how many penguins are going to be coming for dinner?\".*\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\" code-summary=\"textOutput penguins\"}\nui <- fluidPage(\n  textInput(\"name\", \"what is your name\"),\n  actionButton(\"greet\", \"Greet\"),\n  textOutput(\"greeting\"),\n  textOutput(\"first_letter\"),\n  # \"how many penguins are going to be coming for dinner?\"\n  textOutput(\"penguins\")\n)\n```\n:::\n\n\n> *And so let's just add this into our app. I'm just going to run it for demonstration purposes.*\n\n![](img/penguins.png){width=\"80%\" fig-align=\"center\"}\n\n\n> *And I click `Greet.` It said, `\"Hello Barret.\"`*\n> \n> *`\"The first letter in your name is b!\"`* \n> \n> *And there are [322] penguins coming for dinner.*\n\n![](img/penguins_01.png){width=\"70%\" fig-align=\"center\"}\n\n> *...if I keep hitting `Greet`, if we look as to where this `penguin_count()` is coming from, it's coming from this `authenticated_database_request()`, or something that I'm going to have returned random data.*\n\nBelow is a simulated `authenticated_database_request()` reactive: \n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\" code-summary=\"simulated authenticated_database_request\"}\n  # simulate database request\n  authenticated_database_request <- isolate({\n    reactive({\n      data.frame(x = vector(\n        mode = \"integer\",\n        length = sample(\n          x = c(320:340),\n          size = 1,\n          replace = TRUE\n        )\n      ))\n    })\n  }) %>% \n    bindEvent({input$greet})\n```\n:::\n\n\nThis is added to the app `server` as the `penguin_count()` reactive:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\" code-summary=\"simulated authenticated_database_request\"}\n  penguin_count <- reactive({\n    penguin_data <- authenticated_database_request()\n    nrow(penguin_data)\n  })  %>% \n    bindEvent({input$greet})\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\" code-summary=\"output penguins\"}\n  output$penguins <- renderText({\n    paste0(\"There are \", penguin_count(), \" penguins coming for dinner\")\n  })\n```\n:::\n\n\n\n> *And so if I click `Greet` again, now it's [336], [328]...*\n\n![](img/penguins_02.png){width=\"70%\" fig-align=\"center\"}\n\n![](img/penguins_03.png){width=\"70%\" fig-align=\"center\"}\n\n> *This is not deterministic at all. And this is, therefore, not useful for testing. Because if you keep running this test over and over, it will fail. There will be no way for it to be correct, because the data changes underneath. So instead, we can listen to our flag.*\n\n### Test database request\n\n> *So I'm going to change, just wrap this one part and say if we'll get an option of `shiny.testmode`, we'll default this value to `FALSE`. But if it's `TRUE`, then I want to return a `test_database_request()`.*\n\nBelow is a simulated `test_database_request()` reactive: \n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\" code-summary=\"test_database_request()\"}\n  test_database_request <- isolate({\n    reactive({\n      data.frame(x = vector(\n        mode = \"integer\",\n        length = 68L\n      ))\n    })\n  }) %>%\n    bindEvent({input$greet})\n```\n:::\n\n\nThis is added to the control flow for `penguin_count()`, along with `\"shiny.testmode\"`\n\n> *So this is something that returns static data, and will only retrieve what I want it to have. Otherwise, if I'm not in test mode, then let's just do the `authenticated_database_request()`. This will be stored into `penguin_data`, and then the `penguin_data` will count the number of rows, and then hopefully we have a consistent count. Now, if I just run my app and reload app, this is not in testing mode. So we should still see our original behavior.*\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\" code-summary=\"add to penguin_count() in server\"}\n  penguin_count <- reactive({\n    penguin_data <- \n    if (getOption(\"shiny.testmode\", FALSE)) {\n      test_database_request()\n    } else {\n      authenticated_database_request()\n    }\n    nrow(penguin_data)\n  })  %>% \n    bindEvent({input$greet})\n```\n:::\n\n\n![](img/penguins_04.png){width=\"70%\" fig-align=\"center\"}\n\n> *So I see `Barret`. We see `Greet`. It's something like [331], or different amount of each time when I click `Greet`. But let's run this just looking at our application...*\n\n#### In the console\n\nBack in `test-shinytest2.R`\n\n> *So if I run this with the app, and I call `app$view()`, so [the app] opens up into chromium based browser...I have `\"What's your name.\"`*\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\" code-summary=\"reset AppDriver/app$view() in console\"}\napp <- AppDriver$new(name = \"export values\")\napp$view()\n```\n:::\n\n\n![](img/shiny.testmode_01.png){width=\"95%\" fig-align=\"center\"}\n\n> *We call `app$set_input()` to `Barret`.*\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\" code-summary=\"run app$set_inputs() in console\"}\napp$set_inputs(name = \"Barret\")\n```\n:::\n\n\n![](img/shiny.testmode_02.png){width=\"95%\" fig-align=\"center\"}\n\n> *We call app `Greet`. We can see that updated. And here it says, `\"Hello Barret. The first letter your name is b.\"`*\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\" code-summary=\"run app$click() in console\"}\napp$click(\"greet\")\n```\n:::\n\n\n![](img/shiny.testmode_03.png){width=\"95%\" fig-align=\"center\"}\n\n\n> *And there are `68` penguins coming for dinner. It's a funny phrase, but it's `68`. It's not 300. And so if I click `Greet` again, and again, and again, and again, `68` is now constant. And it's still going to stay there.*\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\" code-summary=\"run app$click() in console\"}\napp$click(\"greet\")\napp$click(\"greet\")\napp$click(\"greet\")\napp$click(\"greet\")\n```\n:::\n\n\n![](img/shiny.testmode_04.png){width=\"95%\" fig-align=\"center\"}\n\n> *If I look at the values to see what we have, `app$get_values()`, I have `output$penguins`, there are 68 penguins coming for dinner. *\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\" code-summary=\"run app$get_values() in console\"}\napp$get_values()\n#>> $input\n#>> $input$greet\n#>> [1] 2\n#>> attr(,\"class\")\n#>> [1] \"shinyActionButtonValue\" \"integer\"               \n#>> \n#>> $input$name\n#>> [1] \"Barret\"\n#>> \n#>> \n#>> $output\n#>> $output$first_letter\n#>> [1] \"The first letter in your name is b!\"\n#>> \n#>> $output$greeting\n#>> [1] \"Hello Barret!\"\n#>> \n#>> $output$penguins\n#>> [1] \"There are 68 penguins coming for dinner\"\n#>> \n#>> \n#>> $export\n#>> $export$first_letter\n#>> [1] \"b\"\n```\n:::\n\n\n### Export test value\n\n> *I could actually update that, so that we have another exported test value of the `penguin_count()`. So if I update with the `penguin_count()`, say `penguin_count = a reactive expression`, where I export that `penguin_count()`...save it...*\n\nIn the app `server`\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\" code-summary=\"add to exportTestValues() in app server\"}\nshiny::exportTestValues(\n  first_letter = \n    first_letter(),\n  penguin_count = \n    penguin_count()\n  )\n```\n:::\n\n\n> *and then I'm going to stop this app here.*\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\" code-summary=\"app$stop()\"}\napp$stop()\n```\n:::\n\n\n\n\n> *And then I'm just going to restart those interactive tests, where I run app, and I click `Greet`. And let's view it. Now, I don't need to necessarily open up the viewer at the beginning. It's usually useful when debugging errors.* \n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\" code-summary=\"reset AppDriver/app$view() in console\"}\napp <- AppDriver$new(name = \"export values\", height = 483, width = 862) \napp$set_inputs(name = \"Barret\")\napp$click(\"greet\")\n```\n:::\n\n\n\n> *But it's still says `68`.*\n\n![](img/shiny.testmode_05.png){width=\"95%\" fig-align=\"center\"}\n\n> *And `app$get_value()` of `export = penguin_count` is `68`.*\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\" code-summary=\"run app$get_value() in console\"}\napp$get_value(export = \"penguin_count\")\n#>> [1] 68\n```\n:::\n\n\n\n> *Perfect. So now we can make assertions on this value, and it'll be consistent every single time. This is just so useful for getting around those database calls that take 5, 10 minutes to execute, or you're asking a different API about something that is outside the control of Shiny. We want these unit tests to be consistent and fast. That way you want to do them, and you want to do them often.*\n\n# Resources\n\n1. [`shinytest2` package website](https://rstudio.github.io/shinytest2/index.html) \n2. [Unit testing with `shinytest2` talk](https://www.youtube.com/watch?v=DMgAW4m5aTI) ",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}